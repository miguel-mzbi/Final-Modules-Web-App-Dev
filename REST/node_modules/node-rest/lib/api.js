'use strict'

// Sugar
var Util = require('./util/sugar');
var BufferedStream = require('bufferedstream');

// Core Deps
var path  = require('path');
var Emitter = require('events').EventEmitter;

// Other Dependencies
var _       = require('underscore');
var strata  = require('strata');
var lingo   = require('lingo');
var en      = lingo.en;

// Borrowed Helper functions from Backbone.js
// ===========================================
var ctor = function(){};

// Helper function to correctly set up the prototype chain, for subclasses.
// Similar to `goog.inherits`, but uses a hash of prototype properties and
// class properties to be extended.
var inherits = function(parent, args) {
  var protoProps;
  var staticProps;
  var child;
  var name;

  if (Util.typeOf(args[0]) === "string") {
    name = args[0];
    protoProps = args[1];
    staticProps = args[2];
  } else {
    protoProps = args[0];
    staticProps = args[1];
  }

  if (protoProps && protoProps.hasOwnProperty('constructor')) {
    child = protoProps.constructor;
  } else {
    child = function(){ parent.apply(this, args); };
  }

  _.extend(child, parent);

  ctor.prototype = parent.prototype;
  child.prototype = new ctor();

  if (protoProps) _.extend(child.prototype, protoProps);

  if (staticProps) _.extend(child, staticProps);

  child.prototype.constructor = child;

  child.__super__ = parent.prototype;

  return child;
}

// Self-propagating extend function.
// Create a new class that inherits from the class found in the `this` context object.
// This function is meant to be called in the context of a constructor function.
var extend = function () {
  var args = [];
  Array.prototype.push.apply( args, arguments );

  var child = inherits(this, args);
  child.extend = this.extend;
  return new child;
};
// ===========================================


var wrapRequest = function (type) {

  return function (route, middleware, origCallback) {
    var self = this;
    var request = new Request;
    var route;

    // construct route
    // if ( type === 'post' ) {
    //   route = "/" + path.join(self._baseUrl, self._version, en.pluralize(self._resource), route);
    // } else {
    route = "/" + path.join(self._baseUrl, self._version, en.pluralize(self._resource), route);
    // }

    if (Util.typeOf(middleware) !== 'array') {
      origCallback = middleware;
      middleware = [];
    }

    // Defaults
    middleware = middleware || [];

    // TODO: OnRequest callback
    // Can be optimized heavily !
    var cb = function (env, callback) {
      var req = strata.Request(env);
      // TODO: workaround for not being able to stream inside req.params
      var inputStream = new BufferedStream();
      env.input.pipe(inputStream);

      req.params(function (err, params) {
        // Construct new env variable
        env.input = inputStream;
        // Validate Request Parameters if present
        env.params = params;

        // Run Route Middlewares
        (function pass(i, fn, fnArgs) {
          var err = fnArgs[0];
          var env = fnArgs[1];
          var customCallback;

          // Call original Callback if no middleware present
          if (Util.typeOf(middleware[i]) === 'undefined') {

            customCallback = function (err, headers, data) {
              if (Util.typeOf(data) === 'undefined') {
                data = headers || {}; //always data has to be initialized
                headers = undefined; // obviously no headers have been defined
              }
              // Set some defaults
              headers = headers || {};
              err = err || undefined;
              data = data || {};

              switch(env.route.format || self._format) {
                case 'json':
                  headers['Content-Type'] = "application/json";
                  data = JSON.stringify(data);
                  err = (err && JSON.stringify(err)) || undefined;
                break;
                case 'xml':
                  headers['Content-Type'] = "application/xml";
                  data = Util.json2xml({
                    root: data
                  });
                  err = (err && Util.json2xml(err)) || undefined;
                break;
              }
              if ( Util.typeOf(err) === 'undefined' ) {
                callback(200, headers, data);
              } else {
                callback(400, headers, err);
              }
            }
            // call if callback
            if (origCallback) {
              origCallback.call(self, err, env, customCallback);
            } else {
              // emit callback
              request.emit('req', err, env, customCallback);
            }
            return;
          }

          // Call Middlewares if present
          fn.call(self, err, env, function ( newErr ) {
            i += 1;
            err = newErr || err;
            pass(i, middleware[i], [err, env]);
          });
        })(0, middleware[0], [err, env]);
      });
    }
    // Collect Endpoints which can be 'mounted' later
    self._endpoints.push([type, route, cb]);
    return request;
  }
}

// One time
var mount = function (resources) {
  if (Util.typeOf(resources) !== 'array') {
    resources = [resources];
  }
  resources.forEach(function (resource) {
    resource._endpoints.forEach(function (endpointArgs) {
      strata[endpointArgs.shift()].apply(resource, endpointArgs);
    });
  });
}

var configure = (function () {
  var defaults = {
    version   : 1,
    baseUrl   : '',
    format    : 'json'
  };

  return function (opts) {
    if (Util.typeOf(opts) !== 'undefined') {
      defaults = _.extend({}, defaults, opts);
    }
    return defaults;
  }
})();


/**
@class Request
Strictly used for validation and event emits
@constructor
*/
var Request = function () {
  this._params = {};
}

_.extend(Request.prototype, Emitter.prototype, {
  /**
  Set params for request to validate against
  */
  params: function (opts) {
    _.extend(this._params, opts);
    return this;
  }
});


/**
@class API
@constructor
@param [name] {String} API Resource name
@param [options] {Object} Default options when extending API class
  @param [options.version=1] {Number)
  @param [options.baseUrl='/'] {String}
  @param [options.format='json'] {String}
*/
var API = function (name, opts) {

  if (Util.typeOf(opts) !== 'object') {
    opts = {};
  }

  opts = _.extend({}, configure(), opts);
  this._resource = name.toLowerCase();

  this._version = opts.version;
  this._baseUrl = opts.baseUrl;
  this._format  = opts.format;

  this._endpoints = []
}

API.prototype = {
  get   : wrapRequest.call(this,'get'),
  post  : wrapRequest.call(this,'post'),
  put   : wrapRequest.call(this,'put'),
  delete: wrapRequest.call(this,'delete'),
  head  : wrapRequest.call(this,'head'),
  options: wrapRequest.call(this,'options')
};

API.configure = configure;
API.extend = extend;
API.mount = mount;

// Export Strata Core
API.run = strata.run;
API.use = strata.use;

// Export Strata Middlewares
API.authenticityToken = strata.authenticityToken;
API.basicAuth = strata.basicAuth;
API.build = strata.build;
API.cascade = strata.cascade;
API.commonLogger = strata.commonLogger;
API.contentLength = strata.contentLength;
API.contentType = strata.contentType;
API.directory = strata.directory;
API.file = strata.file;
API.flash = strata.flash;
API.gzip = strata.gzip;
API.jsonp = strata.jsonp;
API.lint = strata.lint;
API.methodOverride = strata.methodOverride;
API.rewrite = strata.rewrite;
API.router = strata.router;
API.sessionCookie = strata.sessionCookie;
API.timeout = strata.timeout;
API.urlMap = strata.urlMap;
API.cors = require('./middleware/cors');

module.exports = API;